# Объектно-ориентированное программирование
## 1) Три принципа ООП
* Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.
* Наследование - это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
* Полиморфизм - это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

## 2) Классы
### a) Методы

Объявление и описание:
	
	модификатор_доступа static_or_not тип_возвр_знач Имя_метода(параметры метода)
	{
		тело метода
	}

Перегрузка метода - метод с таким же названием, но с разными входными параметрами.

`static` методы - метод не привязан к объекту, в теле метода нельзя использовать не статические поля и методы класса. Вызов - `ClassName.StaticMethodName(params);`

Метод, помеченный как `override` - переопределённый метод. При переопределении метода базового класса должна совпадать сигнатура метода.

	Base bs = new Child();
	bs.MethodExample() // Child.MethodExample();

Метод, помеченный как `new` - скрытие метода. 

	Base bs = new Child();
	bs.MethodExample(); // Base.MethodExample();
	((Child)bs).MethodExample() // Child.MethodExample();
	
Метод, помеченный как `virtual` можно переопределить.  
Метод, помеченный как `abstract` не реализован. Либо нужно переопределить, либо сделать класс абстрактным.

### b) Поля

Объявление пишется в теле класса

	модиф_доступа статик_не_статик тип имя;

Инициализация

	fildName = new TypeField(Params...);

Возможна инициализация при объявлении. Они инициализируются при создании экземпляра класса.

Static поля можно использовать в статических методах. Они инициалируются во время компиляции. Не привязаны к объекту. ClassName.StaticField.

### c) Свойства
Свойства класса - это член, предоставляющий гибкий механизм для чтения, записи или вычисления значения частного (private) поля.

Объявление:

	мод_дост статик_не_статик тип имя 
	{
		мод_дост get
		{
			return obj;
		}

		мод_дост set
		{
			obj = value;
		}
	}

Автоматически реализуемые свойства. Выделяется анонимная память.

Объявление:

	public int prop { get; set; }

Свойство может быть `virtual`, `abstract`, `override`, `new` так же, как и метод. Свойства можно переопределять.

### d) Разница полей и свойств

У get и set свойств есть тела, в них можно запихать какую-то логику, проверку на ошибки и т.д...  
Свойству можно сделать разную степень видимости для записи и чтения.  
Свойство можно переопрделить, скрыть (new).  
Под свойство можно не выделять память (не автоматически реализуемые свойства).  
Свойству можно запретить set или get вообще.  

Свойства нельзя использовать как out / ref параметр  
Если свойство - структура, get будет возвращать копию, если ссылка - копию ссылки)  

## 3) Идентификаторы доступа

> private - виден только внутри класса  
> protected - виден только внутри класса и наследникам  
> internal - виден только в этом проекте  
> public - открыт  

## 4) Полиморфизм методов
Описано в части методы.

## 5) Абстрактные классы
Класс, содержащий один или более методов и свойств, помеченных как abstract (не реализованных) абстрактный `abstract class`. Объект абстрактного класса создать нельзя. Потомки должны либо переопределить `abstract` методы и свойства, либо стать `abstract` классом. Абстрактный класс может не содержать абстрактный методов.

Объявление

	abstract class ClassName
	{
		// Тело класса
	}

## 6) Интерфейсы
Интерфейс содержит нереализованные методы и свойства (public abstract по умолчанию). Если класс наследуется от интерфейса он обязан либо переопределить методы и свойства интерфейса, либо перекрыть их абстрактными методами и свойствами. 
Объявление:

	public interface InterfaceName
	{
		TypeName PropertyName { get; set; }
		int Method1();
		TypeName Method2();
	}

	public abstract class ClassName : InterfaceName
	{
		public abstract TypeName PropertyName { get; set; }
		public abstract int Method1();
		private abstract TypeName Method2();	
	}

При реализации метода наследником можно пометить метод как `private`

	public class ClassName : InterfaceName
	{
		public TypeName PropertyName { get; set; }
		public int Method1() {}
		private TypeName Method2() {}
	}

	public static void Main(string[] args)
	{
		var objName = new ClassName();
		objName.Method2(); // Ошибка во время компиляции
		((InterfaceName)objName).Method2(); // Normal
	}

Коллизия имён, при наследовании от двух интерфейсов решается либо слиянием (реализацией одного метода), либо разделением:

	private void Interface1.MethodName() {realize}
	private void Interface2.MethodName() {realize}

	public void MethodNameOne() {((Interface1)this).MethodName()}
	public void MethodNameTwo() {((Interface2)this).MethodName()}


